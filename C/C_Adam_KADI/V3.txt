VERSION 3 – OBJECTIF ET MÉTHODE

1. Objectif de la version 3

La version 3 a pour objectif de produire un pavage LEGO plus économique que la version 1 tout en respectant au mieux les couleurs de l’image et les stocks de pièces disponibles.

Pour cela, l’algorithme :
- part d’un pavage de base utilisant uniquement des pièces 1x1,
- remplace certaines paires de 1x1 par des pièces 2x1 lorsque cela permet de réduire le prix,
- suit les stocks des pièces et comptabilise les éventuelles ruptures,
- calcule un indicateur de qualité basé sur l’écart entre la couleur d’origine et la couleur choisie.

La version 3 reste donc compatible avec le cahier des charges initial (pavage 1x1) mais l’améliore en termes de coût, en utilisant le matching avec des pièces 2x1.


2. Méthode employée

L’algorithme se décompose en trois grandes étapes :

2.1. Construction du pavage de base (Version 1)

À partir du fichier image :
- chaque pixel est lu au format RRGGBB,
- pour chaque pixel, on parcourt le catalogue et on ne considère que les pièces 1x1,
- on choisit la pièce 1x1 dont la couleur (R, G, B) minimise la distance euclidienne au pixel :
  (ΔR)² + (ΔG)² + (ΔB)²,
- on mémorise pour chaque pixel :
  - la couleur retenue,
  - l’indice de la pièce 1x1 choisie,
  - l’erreur associée (distance RGB²).

La somme de toutes ces erreurs constitue la qualité de référence du pavage de base.

2.2. Matching de pièces 2x1 (Version 2)

On modélise la grille de pixels comme un graphe dont :
- les sommets sont les cases (x, y),
- les arêtes relient deux cases voisines (haut, bas, gauche, droite).

On considère une arête (u, v) admissible si :
- les deux pixels ont la même couleur choisie en V1,
- il existe dans le catalogue une pièce 2x1 de cette couleur,
- le prix de cette pièce 2x1 est strictement inférieur à la somme des prix des deux 1x1 correspondants.

On construit alors un matching maximum sur ce graphe biparti (cases « noires » vs « blanches » d’un damier) en utilisant des chemins alternants (DFS) :
- on part des sommets libres d’une couleur du damier,
- on cherche des chemins alternés libre/matché pour augmenter le matching,
- chaque augmentation correspond à une nouvelle paire de pixels couverts par une pièce 2x1.

À l’issue de cette étape, certaines cases sont couplées par une pièce 2x1 (edges du matching), les autres resteront en 1x1.

2.3. Génération du pavage final et gestion des stocks

On parcourt la grille et on génère le fichier de sortie « pavage » :
- pour chaque paire (u, v) du matching (traitée une seule fois) :
  - on essaie d’utiliser la pièce 2x1 correspondante (même couleur, même orientation),
  - si elle existe :
    - on décrémente son stock,
    - si le stock devient négatif, on incrémente le compteur de ruptures,
    - on écrit une ligne : ID_2x1 x y rotation (0 pour horizontale, 90 pour verticale),
    - on ajoute son prix au prix total,
    - on ajoute les deux erreurs V1 (u et v) à la qualité totale.
  - si aucune 2x1 adaptée n’existe, on retombe sur deux pièces 1x1 (une sur chaque pixel de la paire).

- pour chaque pixel non matché (pas de voisin en 2x1) :
  - on pose sa pièce 1x1 en utilisant l’indice mémorisé lors de la V1,
  - on décrémente le stock de cette pièce,
  - on met à jour les ruptures, le prix total et la qualité totale.

La sortie finale est :
- un fichier de pavage contenant une ligne par pièce posée :
  ID x y rotation
- une ligne résumant le pavage écrit sur la sortie standard :
  chemin_sortie prix_total qualité_totale ruptures_stock

Pour faire court, la version 3 produit un pavage basé sur la couleur optimale en 1x1, l’améliore avec des pièces 2x1 via un matching optimal, tout en prenant en compte les contraintes de stock et le coût global.
