package fr.uge.univ_eiffel.mediators;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

class OrderManagerTest {

    // JUnit 5 magic: Creates a temporary folder that deletes itself after the test
    @TempDir
    Path tempDir;

    @Test
    void parseSolutionCounts_ShouldAggregateBricksCorrectly() throws IOException {
        // 1. ARRANGE: Create a fake "output.txt" file
        File fakeOutput = tempDir.resolve("output.txt").toFile();

        // Simulate the file content generated by your C program:
        // Line 1: Header (Price/Quality) -> Must be skipped
        // Line 2: Brick A
        // Line 3: Brick A again (Count should be 2)
        // Line 4: Brick B
        // Line 5: Empty line -> Must be skipped
        List<String> lines = List.of(
                "Price: 500, Quality: 100",
                "2-4/red,0,10,20",
                "2-4/red,1,14,20",
                "1-1/blue,0,0,0",
                ""
        );
        Files.write(fakeOutput.toPath(), lines);

        // 2. ACT: Call the static parser
        HashMap<String, Integer> counts = OrderManager.parseSolutionCounts(fakeOutput.getAbsolutePath());

        // 3. ASSERT
        assertNotNull(counts);

        // Check "2-4/red" -> Should be 2
        assertTrue(counts.containsKey("2-4/red"));
        assertEquals(2, counts.get("2-4/red"), "Should sum up duplicate brick entries");

        // Check "1-1/blue" -> Should be 1
        assertEquals(1, counts.get("1-1/blue"));

        // Check Header -> Should be ignored
        assertFalse(counts.containsKey("Price: 500"), "Header line should be skipped");
    }

    @Test
    void parseSolutionCounts_ShouldHandleMissingFile_Gracefully() {
        // ARRANGE
        String missingPath = tempDir.resolve("ghost_file.txt").toString();

        // ACT
        // Your code catches the IOException and prints an error, returning an empty map.
        // We want to ensure it doesn't crash the program.
        HashMap<String, Integer> counts = OrderManager.parseSolutionCounts(missingPath);

        // ASSERT
        assertNotNull(counts);
        assertTrue(counts.isEmpty(), "Should return empty map if file is missing");
    }
}